namespace BCN.KandyToys.DataBridge.Utilities;

using Microsoft.Finance.GeneralLedger.Setup;

codeunit 50505 FileExportHelper
{
    internal procedure CreateBatch(var PassedEVSDBCMessageBatch: Record EVS_DBC_MessageBatch; ProcessCode: Code[20]; ParentMessageBatchID: Integer; Required: Boolean)
    begin
        Clear(PassedEVSDBCMessageBatch);
        PassedEVSDBCMessageBatch.Validate(EVS_DBC_ProcessCode, ProcessCode);
        PassedEVSDBCMessageBatch.Validate(EVS_DBC_ParentBatchID, ParentMessageBatchID);
        PassedEVSDBCMessageBatch.Insert(true);
    end;

    internal procedure WriteBatchWithoutDelimiter(var BufferOutstream: Outstream; var DataBuffer: array[100] of Text; ArrayLength: Integer)
    var
        ArrayCounter: Integer;
        TextBuilder: TextBuilder;
    begin
        Clear(TextBuilder);

        for ArrayCounter := 1 to (ArrayLength - 1) do
            TextBuilder.Append(DataBuffer[ArrayCounter]);

        TextBuilder.Append(DataBuffer[ArrayLength]);

        BufferOutstream.WriteText(TextBuilder.ToText());
        BufferOutstream.WriteText();
    end;

    internal procedure WriteBatch(var BufferOutstream: Outstream; var DataBuffer: array[100] of Text; ArrayLength: Integer)
    var
        ArrayCounter: Integer;
        TextBuilder: TextBuilder;
        Delimiter: Text;
    begin
        Clear(TextBuilder);
        Delimiter := ',';

        for ArrayCounter := 1 to (ArrayLength - 1) do
            TextBuilder.Append(DataBuffer[ArrayCounter] + Format(Delimiter));

        TextBuilder.Append(DataBuffer[ArrayLength]);

        BufferOutstream.WriteText(TextBuilder.ToText());
        BufferOutstream.WriteText();
    end;

    internal procedure FinaliseBatch(var PassedEVSDBCMessageBatch: Record EVS_DBC_MessageBatch; PassedFileName: Text; Required: Boolean)
    var
        EVS_DBC_MessageStatus: Enum EVS_DBC_MessageStatus;
    begin
        PassedEVSDBCMessageBatch.CalcFields(EVS_DBC_ImportExportFile);
        if PassedEVSDBCMessageBatch.EVS_DBC_ImportExportFile.Length = 0 then begin
            PassedEVSDBCMessageBatch.Delete();
            exit;
        end;
        PassedEVSDBCMessageBatch.EVS_DBC_ImportExportFileName := CopyStr(PassedFileName, 1, MaxStrLen(PassedEVSDBCMessageBatch.EVS_DBC_ImportExportFileName));
        PassedEVSDBCMessageBatch.EVS_DBC_ImpExpdDateTime := CurrentDateTime;
        PassedEVSDBCMessageBatch.EVS_DBC_MessageStatus := EVS_DBC_MessageStatus::Exported;
        PassedEVSDBCMessageBatch.Modify(true);
    end;

    internal procedure FinaliseParentBatch(var PassedEVSDBCMessageBatch: Record EVS_DBC_MessageBatch; PassedFileName: Text; Required: Boolean; MarkAsProcessed: Boolean)
    var
        EVS_DBC_MessageStatus: Enum EVS_DBC_MessageStatus;
    begin
        PassedEVSDBCMessageBatch.EVS_DBC_ImportExportFileName := CopyStr(PassedFileName, 1, MaxStrLen(PassedEVSDBCMessageBatch.EVS_DBC_ImportExportFileName));
        PassedEVSDBCMessageBatch.EVS_DBC_ImpExpdDateTime := CurrentDateTime;
        if MarkAsProcessed then
            PassedEVSDBCMessageBatch.EVS_DBC_MessageStatus := EVS_DBC_MessageStatus::Processed
        else
            PassedEVSDBCMessageBatch.EVS_DBC_MessageStatus := EVS_DBC_MessageStatus::Exported;
        PassedEVSDBCMessageBatch.Modify(true);
    end;

    procedure FormatText(TextValue: Text; MaxLength: Integer): Text;
    var
        EVOEFLTextHelper: codeunit EVO_EFL_TextHelper;

        NewValue: Text;
    begin
        if TextValue.Contains('"') then
            TextValue := Delchr(TextValue, '=', '"');
        if TextValue.Contains(',') then
            TextValue := '"' + TextValue + '"';

        NewValue := EVOEFLTextHelper.RemoveControlCharacters(TextValue);
        if MaxLength > 0 then
            NewValue := CopyStr(NewValue, 1, MaxLength);

        exit(NewValue);
    end;

    procedure FormatPadText(TextValue: Text; MaxLength: Integer): Text;
    var
        EVOEFLTextHelper: codeunit EVO_EFL_TextHelper;

        NewValue: Text;
    begin
        if TextValue.Contains('"') then
            TextValue := Delchr(TextValue, '=', '"');
        if TextValue.Contains(',') then
            TextValue := '"' + TextValue + '"';

        NewValue := EVOEFLTextHelper.RemoveControlCharacters(TextValue);
        if MaxLength > 0 then
            NewValue := CopyStr(NewValue, 1, MaxLength);

        NewValue := PadStr(NewValue, MaxLength, ' ');
        exit(NewValue);
    end;


    procedure FormatNoCommaPadText(TextValue: Text; MaxLength: Integer): Text;
    var
        EVOEFLTextHelper: codeunit EVO_EFL_TextHelper;

        NewValue: Text;
    begin
        if TextValue.Contains('"') then
            TextValue := Delchr(TextValue, '=', '"');
        if TextValue.Contains(',') then
            TextValue := Delchr(TextValue, '=', ',');

        NewValue := EVOEFLTextHelper.RemoveControlCharacters(TextValue);
        if MaxLength > 0 then
            NewValue := CopyStr(NewValue, 1, MaxLength);

        NewValue := PadStr(NewValue, MaxLength, ' ');
        exit(NewValue);
    end;


    procedure FormatNoComma(TextValue: Text): Text;
    begin
        if TextValue.Contains('"') then
            TextValue := Delchr(TextValue, '=', '"');
        if TextValue.Contains(',') then
            TextValue := Delchr(TextValue, '=', ',');
        exit(TextValue);
    end;

    procedure FormatText(TextValue: Text): Text;
    begin
        exit(this.FormatText(TextValue, 0));
    end;

    procedure FormatInteger(IntegerValue: Integer; MaxLength: Integer): Text
    var
        NewValue: Text;

        OverflowErr: Label 'Overflow attempting to format value ''%1'' to %2 characters.', Comment = '%1 = Value, %2 = Max Length';
    begin
        NewValue := Format(IntegerValue, 0, 9);

        // Sanity Check.
        //
        if (MaxLength > 0) and (StrLen(NewValue) > MaxLength) then
            Error(OverflowErr, IntegerValue, MaxLength);

        exit(this.FormatText(NewValue, MaxLength));
    end;

    procedure FormatDecimal(DecimalValue: Decimal; MaxLength: Integer; MinDecimalPlaces: Integer; MaxDecimalPlaces: Integer): Text
    var
        NewValue: Text;

        FormatTxt: Label '<Precision,%1:%2><Standard Format,1>', Locked = true;
        OverflowErr: Label 'Overflow attempting to format value ''%1'' to %2 characters with decimal places %3:%4.', Comment = '%1 = Value, %2 = Max Length, %3 = Min DP, %4 = Max DP';
    begin
        NewValue := Format(DecimalValue, 0, StrSubstNo(FormatTxt, MinDecimalPlaces, MaxDecimalPlaces));

        // Sanity Check.
        //
        if (MaxLength > 0) and (StrLen(NewValue) > MaxLength) then
            Error(OverflowErr, DecimalValue, MaxLength, MinDecimalPlaces, MaxDecimalPlaces);

        exit(this.FormatText(NewValue, MaxLength));
    end;

    procedure FormatDecimal(DecimalValue: Decimal; IntegerCharacters: Integer; DecimalCharacters: Integer): Text
    begin
        // Simplified overload.
        //
        exit(this.FormatDecimal(DecimalValue, IntegerCharacters + DecimalCharacters + 1, DecimalCharacters, DecimalCharacters));
    end;

    procedure FormatDate(DateValue: Date): Text
    var
        FormatTxt: Label '<Year4><Month,2><Day,2>', Locked = true;
    begin
        exit(Format(DateValue, 0, FormatTxt));
    end;

    procedure FormatDate(DateTimeValue: DateTime): Text
    begin
        // Allows for DateTime values to be formatted
        exit(this.FormatDate(DT2Date(DateTimeValue)));
    end;

    procedure FormatBoolean(BooleanValue: Boolean): Text[1]
    var
        YesTxt: Label 'Y', Locked = true;
        NoTxt: Label 'N', Locked = true;
    begin
        if BooleanValue then
            exit(YesTxt)
        else
            exit(NoTxt);
    end;

    procedure GetCurrencyCode(CurrencyCode: Code[10]): Code[10]
    var
        GeneralLedgerSetup: Record "General Ledger Setup";
    begin
        if CurrencyCode <> '' then
            exit(CurrencyCode);

        GeneralLedgerSetup.Get();
        exit(GeneralLedgerSetup."LCY Code");
    end;

    procedure NoCommas(var PassedText: Text)
    var
        TxtBuilder: TextBuilder;
    begin
        Clear(TxtBuilder);
        TxtBuilder.Append(PassedText);
        TxtBuilder.Replace(',', ' ');
        PassedText := TxtBuilder.ToText();
    end;
}
